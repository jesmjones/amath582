# -*- coding: utf-8 -*-
"""functions_jj

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kj_BvRiGQWD--XpEp-vV6qK8Vdgt5O0W
"""

# construct DCT matrix
def construct_DCT_Mat( Nx, Ny ):
  '''
  STEP 1A
  '''
  # input : Nx number of columns of image 
  #         Ny number of rows of image 
  # output: D DCT matrix mapping image.flatten() to 
  #         DCT(image).flatten()
  Dx = spfft.dct(np.eye(Nx), axis =0, norm='ortho')
  Dy = spfft.dct(np.eye(Ny), axis = 0, norm='ortho')
  D = np.kron(Dy, Dx)
  return D

# construct inverse DCT matrix
def construct_iDCT_Mat( Nx, Ny ):
  '''
  STEP 1A
  '''
  # input : Nx number of columns of image 
  #         Ny number of rows of image 
  # output: iD iDCT matrix mapping DCT(image).flatten() to 
  #         image.flatten()

  Dx = spfft.idct(np.eye(Nx), axis =0, norm='ortho')
  Dy = spfft.idct(np.eye(Ny), axis = 0, norm = 'ortho')
  D = np.kron(Dy, Dx)
  return D

def display_dct(image, dct):
  '''
  STEP 1B
  takes in resized image, and the dct matrix that it corresponds to
  suggestions from Katherine OHs
  '''
  # Vectorize image using img
  dct_flat = image.flatten()
  # Matrix-vector multiply D and vectorized version of image to get DCT. Remember to use np.dot()
  dct_im = np.dot(dct, dct_flat)
  # Make a plot of DCT. These are the coefficients needed to construct the image from cosines of different frequencies
  plt.figure(figsize=(8,6))
  plt.title('DCTs'); plt.xlabel('dct'), plt.ylabel('cosine frequencies')

  return plt.plot(dct_im)

def display_recons(dct, idct, recon, t):
  """
  STEP 1C
  Displays an image using the methods of the 'matplotlib' library.
  takes in the flattened dct matrix, the idct matrix, an empty image for reconstruction, and thresholds
  """
  # adopted from https://inst.eecs.berkeley.edu/~ee123/sp16/Sections/JPEG_DCT_Demo.html
  for x, i in enumerate(t):
  #Take the absolute value and sort coefficients by size.
    th = np.percentile(dct, 100 * (1 - i)); p = np.where(np.abs(dct) >= th, dct, 0)
  # Reconstruct image by multiplying D-1 by the thresheld DCT
    recon[x,:] = np.dot(idct, p) 
  # plot them
  fig, ax = plt.subplots(nrows=1, ncols=5, figsize=(20,6))
  for i in range(len(t)):
    ax[i].imshow(recon[i,:].reshape(53,41),cmap='gray')
    ax[i].set_title("~ %.1f%% of the DCT coefficients" % (t[i]*100))
    ax[i].axis('off')

# based on Katherine's OH notes and Lec25 notes
# adapted from https://inst.eecs.berkeley.edu/~ee123/sp16/hw/hw9_Compressed_Sensing.html
# https://www.cvxpy.org/tutorial/advanced/index.html
def B_(M, N):
  '''
  STEP 2A-B
   The dimensions of B will be MxN where M is the number of points measured, 
   and N is the number of pixels in the image. Each row of B has a 1 in the column 
   that corresponds to the pixel which is being sampled, so this will be a sparse matrix
  '''
  N = np.eye(N)
  prm = np.random.permutation(N)
  B = prm[0:M, :].copy()
  return B

def approximate_F(flattened_image, M, N, idct):
  '''
  STEP 2C
  Generate your measurements by matrix-vector multiplying B with the flattened image.
  use matrix multiplication and use the hint about settings for cvx. 
  You will define the variable you are minimizing, x,  the objective function, and the
  constraint. 
  '''
  recov = np.empty((9, 2173)); ran = 3 ; index = 0
  B_mat = B_(M,N)
  y = np.dot(B_mat , _flat)
  A_mat = np.dot(B_mat, idct)
  x = cvx.Variable(N)
  # objective = cvx.Minimize(cvx.norm(x,1)), [A_mat @ x == y]
  problem = cvx.Problem(cvx.Minimize(cvx.norm(x,1)), [A_mat @ x == y])
  x_star = problem.solve(verbose=True, solver = 'CVXOPT', max_iter= 1000, 
                    reltol=1e-2, featol= 1e-2)
  ans = np.dot(idct, x.value)
  return ans

def recov_image_processing(_flat, M, N, idct):
  # takes 30 mins
  '''
  STEP 2D
  '''
  recov = np.empty((9, 2173)); ran = 3 ; index = 0
  for m in M:
    for run in range(ran):
      recov[index, :] = approximate_F(_flat, m, N, idct)
      index += 1
  return recov

def image_recov_mat(n, recovered_image):
  '''
  Plot STEP 2C
  '''
  fig , ax = plt.subplots(n,n, figsize=(20,20))
  index = 0
  for i in range(n):
    for j in range(n):
      # To see how the image reconstruction performed, 
      # reshape the product of D-1 times x* to the image dimension
      ax[i][j].imshow(recovered_image[index, :].reshape(53,41), cmap='gray')
      ax[i][j].axis('off')
      index +=1
  return plt.tight_layout()

def approximate_unknown_plot(B, idct_un, N, y):
  '''
  STEP 3
  Does approximate_F() but on the unknown image and plots the result
  '''
  A_mat = np.dot(B, idct_un)
  x = cvx.Variable(N)
  # objective = cvx.Minimize(cvx.norm(x,1)), [A_mat @ x == y]
  problem = cvx.Problem(cvx.Minimize(cvx.norm(x,1)), [A_mat @ x == y])
  x_star = problem.solve(verbose=True, solver = 'CVXOPT', max_iter= 1000, 
                         reltol=1e-2, featol= 1e-2)
  ans = np.dot(idct_un, x.value)
  plt.imshow(ans.reshape(50,50), cmap='gray')
  return plt.show()